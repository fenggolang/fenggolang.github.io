<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hugo tranquilpeak theme</title>
    <link>https://fenggolang.github.io/post/</link>
    <description>Recent content in Posts on Hugo tranquilpeak theme</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 01 Sep 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://fenggolang.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>golang项目常用框架技术选型</title>
      <link>https://fenggolang.github.io/2018/09/golang%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</link>
      <pubDate>Sat, 01 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://fenggolang.github.io/2018/09/golang%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</guid>
      <description>&lt;p&gt;做一个golang项目，免不了需要选型框架，下面整理了一份常用的技术选型框架。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>docker核心技术以及实现原理</title>
      <link>https://fenggolang.github.io/2018/08/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 19 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://fenggolang.github.io/2018/08/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;p&gt;设计docker核心技术以及底层实现原理，比如命名空间、CGroups,存储驱动，容器网络&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>deepin linux共享文件给windows</title>
      <link>https://fenggolang.github.io/2018/08/deepin-linux%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E7%BB%99windows/</link>
      <pubDate>Sat, 18 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://fenggolang.github.io/2018/08/deepin-linux%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E7%BB%99windows/</guid>
      <description>&lt;p&gt;deepin linux下使用samba服务共享文件给windows访问&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ansible部署openshift集群</title>
      <link>https://fenggolang.github.io/2018/08/ansible%E9%83%A8%E7%BD%B2openshift%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Sat, 11 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://fenggolang.github.io/2018/08/ansible%E9%83%A8%E7%BD%B2openshift%E9%9B%86%E7%BE%A4/</guid>
      <description>&lt;p&gt;ansible安装部署openshift集群,prometheus,grafana,logging(elasticsearch,fluentd,kibana)
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>大牛博客,友情链接.</title>
      <link>https://fenggolang.github.io/2018/08/%E5%A4%A7%E7%89%9B%E5%8D%9A%E5%AE%A2%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5./</link>
      <pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://fenggolang.github.io/2018/08/%E5%A4%A7%E7%89%9B%E5%8D%9A%E5%AE%A2%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5./</guid>
      <description>&lt;p&gt;记录网上大牛的博客地址&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>谈谈golang中的interface</title>
      <link>https://fenggolang.github.io/2018/08/%E8%B0%88%E8%B0%88golang%E4%B8%AD%E7%9A%84interface/</link>
      <pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://fenggolang.github.io/2018/08/%E8%B0%88%E8%B0%88golang%E4%B8%AD%E7%9A%84interface/</guid>
      <description>&lt;hr /&gt;

&lt;h4 id=&#34;前言&#34;&gt;前言&lt;/h4&gt;

&lt;p&gt;如果说goroutine和channel是Go并发的两大基石，那么接口是Go语言编程中数据类型的关键。在Go语言的实际编程中，几乎所有的数据结构都围绕接口展开，接口是Go语言中所有数据结构的核心。&lt;/p&gt;

&lt;p&gt;Go不是一种典型的OO语言，它在语法上不支持类和继承的概念。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>golang控制goroutine的几种方式比较</title>
      <link>https://fenggolang.github.io/2018/08/golang%E6%8E%A7%E5%88%B6goroutine%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</link>
      <pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://fenggolang.github.io/2018/08/golang%E6%8E%A7%E5%88%B6goroutine%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</guid>
      <description>&lt;p&gt;WaitGroup是一种控制并发的方式，它的这种方式是控制多个goroutine同时完成.一个很简单的例子，比如2个goroutine要同时都做完了，才算是完成，先做好的就要等着其他未完成的，所有的goroutine要都全部完成才可以.编程模式是wg.Add()-&amp;gt;wg.Done()-&amp;gt;wg.Wait()&lt;/p&gt;

&lt;p&gt;另外一种是chan通知方式通知其他goroutine说我这个goroutine结束了，编程模式是select-&amp;gt;case &amp;lt;- chan&lt;/p&gt;

&lt;p&gt;通过Context来通知，编程模式是select-&amp;gt;case &amp;lt;- ctx.Done() -&amp;gt; cancel()&lt;/p&gt;

&lt;p&gt;Context控制多个goroutine,编程模式&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes源代码阅读之环境搭建</title>
      <link>https://fenggolang.github.io/2018/08/kubernetes%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://fenggolang.github.io/2018/08/kubernetes%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>&lt;p&gt;要阅读kubernetes源代码首先得在本机搭建好环境，注意，只能在linux、MacOS下，不能在windows下(因为kubernetes源代码中含软连接，这在windows下无法识别)&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fenggolang.github.io/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fenggolang.github.io/1/01/</guid>
      <description>类型别名(go1.9的新特性) ​ 类型别名和原类型完全一样，只不过是另一种叫法而已。
​ 我们可以用关键字type声明自定义的各种类型。当然了，这些类型必须在Go语言基本类型和高级类型的范畴之内。在它们当中，有一种被叫做别名类型的类型，如下声明它：
// 为类型string取一个别名 // 这条声明语句表示，MyString是string类型的别名类型。顾名思义，别名类型与其源类型的区别恐怕只是在名称上，它们是完全相同的。 // 源类型与别名类型是一对概念，是两个对立的称呼。别名类型主要是为了代码重构而存在的， // https://github.com/golang/proposal/blob/master/design/18130-type-alias.md type MyString = string  ​ Go1.9中内建的基本类型中就存在两个别名类型
 byte是unint8的别名类型 rune是int32的别名类型  type byte = uint8 type rune = int32  潜在类型(也叫类型再定义) ​ 下面声明一个类型再定义
// 类型再定义，注意这里没有等号 // MyString2和string就是两个不同的类型了，这里的MyString2是一个新的类型，不同于其他任何类型 // 这种方式也可以被叫做对类型的再定义。我们刚刚把string类型再定义成了另外一个类型MyString2 // 对于这里的类型再定义来说，string可以被称为MyString2的潜在类型。潜在类型的含义是某个类型在本质上是哪个类型或者是哪个类型的集合 // 潜在类型相同的不同类型的值是可以进行类型转换的。因此MyString2类型的值与string类型的值可以使用类型转换表达式进行互转。 // 但是对于集合类的类型[]MyString2与[]string来说这样做却是不合法的，因为[]MyString2与[]string的潜在类型不同，分别是MyString2和string // 另外，即使两个类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值 type MyString2 string  类型别名声明与类型再定义之间的区别 // 定义类型别名 // 类型别名和原类型完全一样，可以随意命名，增加代码可读性，拓展外部访问权限 type newType = oldType // 定义新类型 type newType oldType  ​ 所以类型别名和类型定义最大的区别在于：类型别名和原类型是相同的，而类型定义和原类型是不同的两个类型。</description>
    </item>
    
  </channel>
</rss>